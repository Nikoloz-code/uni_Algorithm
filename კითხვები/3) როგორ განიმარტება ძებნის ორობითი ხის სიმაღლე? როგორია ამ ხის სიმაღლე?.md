***__როგორ განიმარტება ძებნის ორობითი ხის სიმაღლე? როგორია ამ ხის სიმაღლე?__***
----------------------------------
სანამ მაგაზე ვისაუბრებ, მოდით უცბად ვახენოთ რა არის რეკურსიული ფუნქცია. რეკურსიული ფუნქცია არის ისეთი ფუნქცია რომელიც თავისივე თავში თავის თავს იძახებს. რადგან თავის თავს იძახებს სამუდამოდ, უნდა გვქონდეს რაიმე if check რითაც ვასწავლით თუ როდის მორჩეს თავისი თავის გამოყენება. თუ გაინტერესებთ უფრო დეტალურად რას აკეთებს, დაგუგლეთ, ბევრი დრო არ გაქვთ ;dd

ეხლა სიმაღლის შესახებ. სიმაღლის ორნაირი გამოთვლის გზაა, მაგრამ განვიხილავ რაც გვაქ კონსპექტებში. ხეში კვანძები სხვადასხვა დონეზე (ანუ სიღრმეზე) არის განთავსებული. განმარტების თანახმად, ფესვის დონედ მიღებულია 0, ხოლო მისგან განსხვავებული ნებისმიერი კვანძის დონე (level) განიმარტება რეკურსიულად: ნებისმიერი კვანძის დონე ერთით მეტია მისი მშობელი კვანძის დონეზე. 

ხოლო **ორობით ხეში, მისი სიმაღლე არის წიბოების უდიდესი რაოდენობა რაიმე კვანძიდან ნებისმიერ ფოთლის გზაზე.** თუ არ გახსოვთ, წიბოები არის ის ხაზები რითაც დაკავშირებულია ჩვენი კვანძები. ხოლო ნებისმიერ ფოთლის გზაზე ვგულისხმობ ყველა მიმართულებას რომელიც აკავშირებს რაიმე კონკრეტულ კვანძს საიდანაც გვინდა დაწყება **ნებისმიერ** ფოთოლ კვანძამდე. მანდედან ვიღებთ მაქსიმალურ წიბოების რაოდენობას და ეგ არის ჩვენი ხის სიმაღლე.
კოდი შემდეგია:
```cpp
int ST_height(link x) {
  if (x == NULL) return -1;
  int u = ST_height(left(x));
  int v = ST_height(right(x));
  return (u < v) ? (v + 1) : (u + 1);
}
```
- **x** აქ არის ის კვანძი რომელსაც ჩვენ ვუთითებთ, ანუ საიდანაც გვინდა რომ დაიწყოს დათვლა. თუ გვინდა ხის მთლიანი სიმაღლის გამოთვლა, ვიწყებთ ფუძე კვანძიდან. თუ **x** უდრის null-ს, ანუ მივედით იმ კვანძამდე რომელსაც არაფერი გააჩნია, ამის გამო ვაბრუნებთ -**1**-ს. რადგან დონე 0-ია.
- სანამ ვისაუბრებ u და v-ზე, როგორც შეამჩნიეთ, სულ სულ ბოლოს გვაქ return. ეს არის ზუსტად რითი ვნახულობთ რომლის წიბოების რაოდენობაა მაქსიმალური.
- **u** და **v** რეკურსიულად იწყებენ ფუნქციის გაშვებას და მათი return-ის შედეგად, მანდ ინახავენ **x** კვანძის მარჯვენა და მარცხენა ქვეხის ყველა კვანძის მიმართულების მაქსიმალურ წიბოების რაოდენობას.
- ბოლოს კი, ჩვენ პირველი ფუნქციის იტერაციაში როცა გვაქ მაქსიმალური მარჯვენა და მარცხენა ქვეხის წიბოების რაოდენობა, ვამოწმებთ თუ რომელი მათგანია მეტი. რომელიც მეტია, მაგას მიმატებული ერთი არის ჩვენი ხის სიმაღლე.
ჩვენი ქვეხის სიტუაციაში:
```
                          55(a1)
                       /          \
                  45(a3)         77(a2)
                        \        /      \
                      46(a5)   56(a4)   80(a6)
```
ვნახოთ ორივე ქვეხის წიბოების რაოდენობა ფუძე კვანძიდან ფოთლამდე
__მარცხენა ქვეხე__
- a1 => a3 => a5, კვანძების რაოდენობაა 2.
- მეტი კვანძი არ გვაქ, ამიტომაც მარცხენა ქვეხის მაქსიმალური წიბოების რაოდენობაა მთლიანობაში 2
__მარჯვენა ქვეხე__
- a1 => a2 => a4, კვანძების რაოდენობაა 2.
- a1 => a2 => a6, კვანძების რაოდენობაა 2.
- აქ მაქსიმალური კვანძების რაოდენობაა 2.
მარცხენა ქვეხის კვანძების რაოდენობაა 2, მარჯვენა ქვეხისაც 2, სწორედ ამის გამო, **ამ ხის სიმაღლე (height) არის 2.**

__კოდის ტრასირება:__
```cpp
ST_height(a1)
|	if(a1 == null) ... //არ შესრულდას აღვნიშნავ სამი წერტილით
|	int u = ST_height(a3) (left(a1) არის a3)
|		| if(a3 == null) ...	
|		| int u = ST_height(null) //left(a3) არის null
|		|	  | if(null = null) return -1; //ანუ ეს u არის -1
|		|
|		| int v = ST_height(a5) //right(a3) არის a5
|		|	  | if (a5 == null) ...
|		|	  | int u = ST_height(null) //left(a5) არ გააჩნია, ამიტომაცაა null
|		|	  |	    | if(null = null) return -1; //ანუ აქ u აქ არის -1
|		|	  |
|		|	  | 
|		|	  | int v = ST_height(null) //right(a5) არ გააჩნია, ამიტომაცაა null
|		|	  | 	    | if(null = null) return -1; //ანუ აქ v აქ არის -1
|		|	  |
|		|	  | return (-1 < -1) ? (-1 + 1) : (-1 + 1); //ანუ მაღლითა v გახდება 0
|		|
|		| return (0 < -1) ? (-1 + 1) : (0 + 1); // [აქ პასუხია (0+1), ანუ 1]
|
|	int v = ST_height(a2) //right(a1) არის a2
|		| if(a2 == null) ...
|		| int u = ST_height(a4) //left(a2) არის a4
|		|	  | if (a4 == null) ...
|		|	  | int u = ST_height(null) //left(a4) არის null
|		|	  |	    | if(null == null) return -1; //u არის -1
|		|	  | int v = ST_height(null) //right(a4) არის null
|		|	  |	    | if(null == null) return -1; //v არის -1
|		|	  | return (-1 < -1) ? (-1 + 1) : (-1 + 1); //ანუ მაღლითა u გახდება 0
|		|
|		| int v = ST_height(a6) //right(a2) არის a6 
|		|	  | if (a6 == null) ...
|		|	  | int u = ST_height(null) //left(a6) არის null
|		|	  |	    | if(null == null) return -1; //u არის -1
|		|	  | int v = ST_height(null) //right(a6) არის null
|		|	  |	    | if(null == null) return -1; //v არის -1
|		|	  | return (-1 < -1) ? (-1 + 1) : (-1 + 1); //ანუ მაღლითა v გახდება 0
|		|
|		| return (0 < 0) ? (0 + 1) : (0 + 1); // [აქ პასუხია ნებისმიერი (0+1), ანუ 1]
|
|	return (1 < 1) ? (1 + 1) : (1 + 1); // [საბოლოო პასუხია ნებისმიერი (1+1), ანუ 2]

[2 არის ხის სიმაღლე].
```
*ამ ალგორითმის მუშაობის დრო კვანძების რაოდენობის პროპორციულია*
