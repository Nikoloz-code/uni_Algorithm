_**მოიყვანეთ პროგრამის ფრაგმენტი, რომელიც შექმნის სიმრავლეს (ხეს), ჩაამატებს მასში მითითებულ გასაღებებს, მოძებნის 70-ს და დაბეჭდავს ძებნის შედეგს**_
---------------------------------------------------------
# დამთავრებული არ მაქ ამ კითხვაზე პასუხი. ბევრი რამე შეიძლება არასწორი იყოს.

```
                          55(a1)
                       /          \
                  45(a3)         77(a2)
                        \        /      \
                      46(a5)   56(a4)   80(a6)
```

```cpp
#include <iostream>
#include<memory>

typedef struct tree_node* link; //link არის ჩვენი tree_node სტრუქტურა. ამით შემოკლებით მივეცით ზედმეტსახლი link რომ ხელით არ ვწეროთ სტრუქტურა
struct tree_node
{
  link left;
  link right;
  link p; //p არის მშობელი
  int data; //data გასაღები
  tree_node() {}
  tree_node(int k) //როდესაც შექმნის დროს ვუთითებთ მთელი რიცხვის მონაცემს
  {
    data = k; //გასაღები ხდება ის მონაცემი რაც მივუთითეთ
    left = right = p = nullptr; //დანარჩენი კი გავანულოთ nullptr-თ. არ დაგვავიწყდეს, ყველა კვანძი არის მისამართი.
  }
};

class BinarySearchTree
{
private:
  link root; //ფუძე კვანძი
public:
  BinarySearchTree(): root(nullptr) {} //როდესაც ხის ობიექტს ვქმნით (რომელიც აუცილებლად მარტო ერთხელ უნდა შეიქმნას) ფუძე კვანძი არის nullptr, ანუ არ გვაქ ჯერ არაფერი.
  ~BinarySearchTree();
  link search(int k) noexcept; //თუ ფუნქცია სწორედ არ მუშაობს, noexcept პირდაპირ წყვეტს (terminates) ფუნქციის კოდის გაშვებას.
  void insert(int) noexcept;
};

void BinarySearchTree::insert(int d) noexcept
{
  //შექმენი ახალი კვანძი გასაღებით d
  link t = new tree_node(d);
  link y = nullptr;
  link x = root;

  // იპოვე კვანძის მშობელი
  while (nullptr != x) //ძებნას ვიწყებთ ფუძე კვანძით, მაგრამ ციკლის მუშაობის x იცვლება ერთ-ერთ თავის შვილზე. 
  {
    y = x; //y ინახავს x-ს სანამ შეიცვლება, ეს კარგი იმისთვის რომ თუ x გახდება null, მის წინ მყოფი კვანძი არის y.
    if (t->data > x->data) x = x->right; //თუ გასაღები მეტია x-ის გასაღებზე, x გახდეს მისი მარჯვენა შვილი, ანუ გადავიდეს მარჯვენა ქვეხეში.
    else x = x->left; //თუ არა, გადავიდეს მარცხენა ქვეხეში.
  }

  //ციკლი როდესაც დამთავრდა, ნაპოვნი გვაქ ახალი კვანძის მშობელი, რომელიცაა y. ამიტომაც მივანიჭოთ მშობელ მონაცემად y.
  t->p = y; 

  if (nullptr == y) //თუ y არის null, ანუ ციკლი არ იმუშავა, ნიშნავს რომ ხე ცარიელია
  {
    root = t; //ამიტომაც ახალი კვანძი გავხადოთ ხის კვანძი და return-ით შევწყვიტოთ ალგორითმის მუშაობა.
    return;
  }

  //თუ არა და, ვნახოთ y-ის რომელი შვილი უნდა გახდეს ახალი კვანძი, მარჯვენა თუ მარცხენა.
  if (d < y->data)
    y->left = t;
  else
    y->right = t;
}

link BinarySearchTree::search(int k) noexcept //k არის ის გასაღები რომლის ტოლი კვანძი. ანუ თუ ვეძებთ 5-ს, ვიპოვით კვანძს გასაღებით 5.
{
  link x = root; //ძებნას ვიწყებთ ფუძიდან
  while (nullptr != x && x->data != k) //სანამ x არ უდრის nullptr-ს და x-ის გასაღები არ უდრის k გასაღებს რასაც ვეძებთ.
  {
    if (k < x->data) //ჩვეულებრივ ვმოძრაობთ ან ერთ მიმართულებაში, ან მეორეში.
      x = x->left;
    else
      x = x->right;
  }
  return x; //დააბრუნებს იმ კვანძის მისამართს რომელსაც აქვს ეგ გასაღები. ხოლო თუ დაგვიბრუნა null, მაშინ ვერ მოძებნა.
}

int main()
{
  BinarySearchTree b; //ამითი ვქმნით ხის კლასის ობიექტს. მარტო გვინდა ერთი შევქმნათ.
  b.insert(55); //ჩასმის დროს 55 გახდება ფუძე კვანძი, დანარჩენი კი განაწილდება ფუძის ერთ-ერთ ქვეხეში.
  b.insert(77);
  b.insert(45);
  b.insert(56);
  b.insert(46);
  b.insert(80);

  link node_address = b.search(70);
  if ( node_address != NULL )
    cout << "Found node with data " << tmp << endl;
  else
    cout << "Not found..." << endl;

  //პასუხს დააბრუნებს Not Found, ანუ ფუნქცია დააბრუნებს nullptrs-ს, რადგან 70-ის მქონე კვანძი არ არის ხეში. 
}
```
