_**__რისი ტოლია a4-ის მომდევნოს მისამართი? a1-ის მომდევნო მისამართი?__**_
----------------------
```
                          55(a1)
                       /          \
                  45(a3)         77(a2)
                        \        /      \
                      46(a5)   56(a4)   80(a6)
```
ამ ხეში რომ დავხედოთ a4-ის გასაღებს, იგი არის 56. მომდევნო მისამართში იგულისხმება ხის მონაცემების ზრდის მიხედვით დალაგების დროს, რომელი იქნებოდა მის შემდეგ რიცხვი. ჩვენ სიტუაციაში, მისი მომდევნო არის 77. ამიტომაც მისი მომდევნო მისამართია a2.
a1-ის მომდევნო მისამართი ამავე ლოგიკით იქნება 56, ანუ a4. ეს ვიზუალურად გასაგებია მაგრამ ალგორითმი როგორ ეძებს მომდევნოს?
```cpp
link ST_successor(link x)
{
  if (NULL != right(x)) return ST_minimum(right(x));
  while (NULL != p(x) && x == right(p(x)))
  {
    x = p(x);
  }
  return p(x);
}
```
ფუნქცია განიხილავს ორ შემთხვევას. 
```if (NULL != right(x)) return ST_minimum(right(x));``` - თუ **x**–ის მარჯვენა შვილი არაცარიელია, მაშინ ამ შვილის ქვეხის მინიმალური ელემენტი არის **x**–ის მომდევნო. მინიმალური ელემენტის ძებნის ალგორითმი შემდეგნაირია:
```cpp
link ST_minimum(link x) {
  while (left(x) != NULL) {
    x = left(x);
  }
  return x;
}
``` 
სადაც x არის მარჯვენა შვილი, რომელშიც მდებარე **მარცხენა ქვეხის კვანძი** **რომელსაც არ გააჩნია მარცხენა შვილი** არის მინიმალური ელემენტი.

მაგრამ, თუ მარჯვენა შვილი ცარიელია, მაშინ დაიწყება შემდეგი ციკლი, რითიც ჩვენ დავიწყებთ მომდევნო მისამართის **ძებნას ზემოთ**:
```cpp
  while (NULL != p(x) && x == right(p(x)))
  {
    x = p(x);
  }
```
- არ დაგვავიწყდეს რომ x ის მისამართი, რომლის გასაღების მომდევნო გვინდა მოვძებნოთ
- ციკლი არ მთავრდება სანამ x მისამართის მშობელი არ უდრის ნულს **და** სანამ x ტოლია  მისი მშობლის მარჯვენა შვილს. აუცილებელია იმის ხსენება, რომ NULL != p(x) უნდა ყოველთვის იყოს პირველი პირობა რასაც ციკლი ამოწმებს, თორე ალგორითმი არასწორედ იმუშავებს.
- ციკლის მიმდინარეობის დროს, x ხდება მისი მშობელი და ციკლი გრძელდება სანამ ერთ-ერთი პირობა არ დაირღვევა.
ბოლოს კი ```return x;``` დააბრუნებს მომდევნო მისამართს.

მოდით გავაკეთოთ კოდის ტრასირება რომ დავინახოთ თუ როგორ ვიპოვით a4-ის და a1-ის მომდევნო მისამართებს:
```cpp
ST_successor(a4)
| if( NULL != NULL) ... //right(a4) არის NULL
| while (NULL != a2 && a4 == a6) ... //p(a4) არის a2, ხოლო a2-ის right შვილი არის a6, პირობა დარღვეულია)
| return a2; 

[a4-ის მისამართის გასაღების მომდევნო მისამართია a2. a4 არის 56, ხოლო a2 არის 77, პასუხი სწორეა]
```
---------------------
```cpp
ST_successor(a1)
| if( NULL != a2) return ST_minimum(a2) //right(a1) არის a2, ამიტომაც პასუხს დააბრუნებს მინიმალურს
|             | while(a4 != null) //a4 არის left(a2)
|             |    | x = a4;
|             | while(null != null) ... //left(a4) არის null
|             | return a4
|

[a1-ის მისამართის გასაღების მომდევნო მისამართია a4. a1 არის 55, ხოლო a4 არის 56, პასუხი სწორეა]
```
